'''
This script creates a training set with images and their corresponding steering angles, and then defines and
trains a CNN regression model to determine the steering angle of a car in a given scneario.
'''

## Import libraries ##
import os

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import sklearn

from keras.models import Sequential, Model
from keras.layers import Lambda, Flatten, Dense, Cropping2D, Convolution2D, Conv2D, Dropout


## Create a training set of data ##

# Parameters to build the train set
use_side_cameras = True
augment_data = True
correction_angle = 0.2

# Read csv file with the paths of the image files and their corresponding steering angles
files_path = 'E:/Eduardo/SDC ND/Proyectos/behavioral clonning/my data/'
logs = pd.read_csv(files_path + 'driving_log.csv',header=None)
logs.columns = ['center_img','left_img','right_img','angle','throttle','break','speed']

# Define function to add an image to the train set, defined as 2 lists, 1 for images and 1 for outputs
def add_image(imgs_list,angles_list,img_path,log_angle,correction_angle,augment_data):
    image =  plt.imread(files_path + 'IMG/' + img_path)
    angle = float(log_angle) + float(correction_angle)
    
    imgs_list.append(image)
    angles_list.append(angle)
    
    # If the boolean argument 'augment_data' is true, then the image is horizontally flipped and
    # the angle's sign is inverted
    if augment_data:
        imgs_list.append(np.fliplr(image))
        angles_list.append(-angle)
        
    return imgs_list, angles_list

# Initialize the lists for the images and the output angles
images = []
angles = []

# Loop through the rows in the csv file generated by the simulator, and add the images and angles
for i in range(len(logs)):
    # Add the center image for each row
    center_path = logs.loc[i,'center_img'].split(os.sep)[-1]
    images, angles = add_image(images,angles,center_path,logs.loc[i,'angle'],0,augment_data)
    
    # If the boolean argument 'use_side_cameras' is true, left and right images are also included,
    # with their angle modified by the 'correction_angle' parameter
    if use_side_cameras:
        left_path = logs.loc[i,'left_img'].split(os.sep)[-1]
        right_path = logs.loc[i,'right_img'].split(os.sep)[-1]

        images, angles = add_image(images,angles,left_path,logs.loc[i,'angle'],correction_angle,augment_data)
        images, angles = add_image(images,angles,right_path,logs.loc[i,'angle'],-correction_angle,augment_data)
        
# Convert the 2 lists to numpy arrays
X_train = np.array(images)
y_train = np.array(angles)


## Define and train model ##

# Define the model's architecture
model = Sequential()
# Normalize the images and crop only the region of interest
model.add(Lambda(lambda x: (x/255.0) - 0.5, input_shape=(160,320,3)))
model.add(Cropping2D(cropping=( (55,25), (0,0) )))
# Define the convolutional, dropout and fully connected layers
model.add(Convolution2D(24,5,5,subsample=(2,2), activation='relu'))
model.add(Convolution2D(36,5,5,subsample=(2,2), activation='elu'))
model.add(Convolution2D(48,5,5,subsample=(2,2), activation='relu'))
model.add(Convolution2D(64,3,3, activation='elu'))
model.add(Convolution2D(64,3,3, activation='relu'))
model.add(Flatten())
model.add(Dense(100,activation='elu'))
model.add(Dropout(rate=0.2))
model.add(Dense(50,activation='elu'))
model.add(Dropout(rate=0.2))
model.add(Dense(10,activation='elu'))
model.add(Dropout(rate=0.1))
model.add(Dense(1))

# Define the loss function and optimizer for the model
model.compile(loss='mse', optimizer='adam')

# Train the model using the training set, with a 20% of the data used for validation
model.fit(X_train, y_train, validation_split=0.2, shuffle=True, epochs=5)

# Save the trained model
model.save('model.h5')
